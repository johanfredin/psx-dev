#ifndef _gpubase_h_
#define _gpubase_h_

#include <LIBGTE.H>
#include <LIBGPU.H>
#include <LIBGS.H>
#include <LIBETC.H>
#include <STRINGS.H>
#include <SYS/TYPES.H>

// Constants
#define NUM_BUFFERS 2
#define OT_LENGTH 5
#define BUFFERS_LENGHT 1
#define MODE_NTSC 0
#define MODE_PAL 1
#define ROT_ONE 4096
#define PACKETMAX 3000
#define FRAME_BUFFER_WIDTH 1024
#define FRAME_BUFFER_HEIGHT 512

// Globals
typedef struct {
    u_short r;
    u_short g;
    u_short b;
} Color;

u_char DebugMode = 0;
u_short screenWidth; 
u_short screenHeight;
GsOT orderingTable[OT_LENGTH];
GsOT_TAG minorOrderingTable[NUM_BUFFERS][20];
PACKET GPUOutputPacket[NUM_BUFFERS][10*sizeof(GsSPRITE)];
u_char currentBuffer = 0;

// Prototypes
void setBounds(u_short w, u_short h);
void initializeScreen(Color* bgColor);
void clearVRAM();
void initializeDebugFont();
void display();
void clearDisplay();
void initDisplayAndDrawEnvs();
void initializeHeap();
GsOT* currentOT();

void setBounds(u_short w, u_short h) {
    screenWidth = w;
    screenHeight = h;
}

void initializeScreen(Color* bgColor) {
    int i;
    SetVideoMode(MODE_PAL);
    SetDispMask(1); // 1=MASK on
	ResetGraph(0);  // Initialise drawing engine, 0=Complete reset
    clearVRAM(bgColor);    

    // Resets libgpu and initializes the graphic system. libpgu settings are maintaned by 
    // the global variables GsDISPENV and GsDRAWENV
    GsInitGraph(screenWidth, screenHeight, GsINTER|GsOFSGPU, 0, 0); 
    
    // Define double buffers
    GsDefDispBuff(0, 0, 0, screenHeight);

    // Initialize ordering tables
    GsClearOt(0, 0, &orderingTable[GsGetActiveBuff()]);
    for(i = 0; i < NUM_BUFFERS; i++) {
        orderingTable[i].length = OT_LENGTH;
        orderingTable[i].org = minorOrderingTable[i];
        GsClearOt(0, 0, &orderingTable[i]);
    }

    PadInit(0);
}

void clearVRAM(Color* bgColor) {
    RECT rect;
    setRECT(&rect, 0, 0, FRAME_BUFFER_WIDTH, FRAME_BUFFER_HEIGHT);
    ClearImage2(&rect, bgColor->r, bgColor->g, bgColor->b);    // Clear Frame Buffer at high speed (interlaced mode)
    DrawSync(0);    // Waits for ClearImage2 function to finish
}

void initializeDebugFont() {
	FntLoad(960, 256);
	SetDumpFnt(FntOpen(5, 5, 320, 240, 0, 512)); //Sets the dumped font for use with FntPrint();
}

void display(Color* backgroundColor) {
    currentBuffer = GsGetActiveBuff();
    DrawSync(0);        // Wait for drawing to end
    VSync(0);           // Wait for vsync (2 = 30FPS moreless)
    GsSwapDispBuff();   // Swap buffers
    
    // Sets a screen clear command at the start of the OT. Should be called after GsSwapDispBuff.
    // Actual clearing isnt executed unti GsDrawOt() is called
    GsSortClear(backgroundColor->r, backgroundColor->g, backgroundColor->b, &orderingTable[currentBuffer]);
    // Starts execution of GPU commands registered in OT
    GsDrawOt(&orderingTable[currentBuffer]);
}

void clearDisplay() {
    currentBuffer = GsGetActiveBuff();
    FntFlush(-1);
    // Set the memory adress for storing drawing commands for drawing primitives generated by functions
    // like GsSortObject(), GsSortSprite() and GsSortBg()
    GsSetWorkBase((PACKET*)GPUOutputPacket[currentBuffer]);
    GsClearOt(0, 0, &orderingTable[currentBuffer]);
}

void initializeHeap() {
	printf("\nReserving 1024KB (1,048,576 Bytes) RAM... \n");
    InitHeap3((void*)0x800F8000, 0x00100000);
}

// GsGetActiveBuff() should have been called prior to calling this function
// @return pointer to ordering table at current buffer
GsOT* currentOT() {
    return &orderingTable[currentBuffer];
}

#endif